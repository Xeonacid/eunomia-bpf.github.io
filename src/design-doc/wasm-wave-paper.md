# 论文阅读：WaVe: 一种可验证安全的WebAssembly沙盒运行时

## 摘要

软件沙盒的优势在于灵活、快速和便携的隔离，能够实现硬件基于内存保护的优点，而不需要涉及操作系统。这一优势在WebAssembly（Wasm）中得到了实现，Wasm是一种流行的可移植字节码，其编译器会自动插入运行时检查，以确保数据和控制流被限制在单个内存段中。事实上，现代编译的Wasm实现已经发展到了这个地步，这些检查本身可以被验证，从而将编译器从可信计算基础中移除。然而，由此产生的完整性属性仅适用于在Wasm沙箱内严格执行的代码。与运行时系统的任何交互都会超出此约定，运行时系统管理沙盒并公开用于访问操作系统资源的WebAssembly系统接口（WASI）。因此，产生的难题是如何在保持Wasm的强隔离特性的同时，允许这些程序与外部世界（例如文件系统、网络等）进行交互。本文提出了一个解决方案，通过WaVe实现WASI，这是一个经过验证的安全运行时系统。我们机械验证与WaVe的交互（包括操作系统副作用）不仅保持Wasm的内存安全保证，而且还保持对主机操作系统存储和网络资源的访问隔离。最后，尽管完全将运行时从可信计算基础中移除，我们展示了WaVe提供了与现有工业级（但不安全的）Wasm运行时相竞争的性能。

## 两个洞见使得WaVe在实践中起作用

首先，我们认为安全策略（例如内存隔离、文件系统隔离和网络隔离）应该是明确的，并与执行分离。这不仅使得WaVe实施的策略清晰（易于审计），而且确保WaVe对所有目标操作系统的所有WASI主机调用实施统一的策略。这也使得安全地扩展运行时系统的新功能变得容易。例如，除了WASI主机调用的核心集合之外，WaVe还公开了WASI-sockets提案[29]中描述的网络主机调用，并实施该提案所描述的安全策略。

我们的第二个洞见是只在必要的程度上对操作系统语义进行建模，以捕捉任何系统调用对安全性的影响。例如，WaVe对POSIX read(fd, buf, count)系统调用的模型并不模拟内核数据结构（例如文件描述符表、inode或缓冲区高速缓存），而只模拟它对内存隔离的影响——read可能会从buf开始写入count个字节——以及它对文件系统隔离的影响——read可能会从文件（描述符）fd中读取。这使得“按需付费”成为可能（例如，如果只关心内存隔离，则不需要指定有关文件描述符的详细信息）。这也使得我们可以在操作系统之间重用规范。例如，虽然POSIX语义实际上在不同的操作系统中存在差异[19]，但我们的抽象语义使得WaVe能够在Linux和MacOS之间大部分共享规范。

## 沙箱运行时的不安全性

沙箱运行时的不安全性可能有两种形式：运行时可能无意中违反了沙箱的内存隔离保证，或者运行时可能错误地限制了沙箱对文件系统或网络等操作系统资源的访问。内存安全漏洞和资源隔离漏洞都可能导致沙箱逃逸。

## Work

WaVe使用WASI来处理沙箱对操作系统资源（hostcalls）的请求。在给定操作系统规范和安全策略的情况下，WaVe静态验证它只执行安全的hostcall。

因此，我们设计 WaVe 时考虑了三个目标：

1）提供两个集中的、明确的规范，一个是安全策略，另一个是系统调用行为。这些规范清晰地说明了运行时必须执行的内容以及每个单独的系统调用的功能。
2）只付出我们所证明的代价，因为详尽地规定系统调用行为是困难且耗时的。相比之下，在 WaVe 中，开发人员仅规定与其安全策略相关的系统调用行为。
3）将操作系统规范与安全策略分离，并将策略规范与其执行分离。WaVe 的安全策略仅存在于一个地方，而不是像运行时在每个系统调用上强制执行正确性。操作系统规范和安全策略也是独立的，这使得测试规范（§6）和在不同的运行时中重用规范和策略变得容易。
