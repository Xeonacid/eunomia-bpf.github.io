# 论文阅读：MSWasm: soundly 强制执行不安全代码的内存安全执行

大多数编译为WebAssembly（Wasm）的程序今天都是用像C和C ++这样的不安全语言编写的。不幸的是，当C代码被编译为Wasm时，内存不安全的问题仍然存在，攻击者几乎可以像在本地平台上一样轻松地利用缓冲区溢出和使用后释放的问题。Memory-Safe WebAssembly（MSWasm）提出了在语言级别扩展Wasm的内存安全抽象，以精确解决这个问题。在本文中，我们在原始的MSWasm立场文件的基础上来实现这一愿景。我们给出了MSWasm的精确和形式化语义，并证明了经过良好类型化的MSWasm程序从构造上是强大的内存安全的。为此，我们开发了一种基于彩色内存位置和指针的新型，语言无关的内存安全属性。该属性还让我们可以推理正式的C到MSWasm编译器的安全保证，并证明它始终会生成内存安全的程序（并保留安全程序的语义）。我们使用这些正式的结果来指导几个实现：两个将MSWasm编译为本地代码的编译器，以及一个扩展Clang的C到MSWasm编译器。我们的MSWasm编译器支持不同的执行机制，允许开发人员根据自己的需要进行安全性能平衡。我们的评估表明，在PolyBenchC套件上，软件实施内存安全的开销范围从22％（仅实施空间安全）到198％（实施完整的内存安全），并且在使用硬件内存能力进行空间安全和指针完整性时为51.7％。更重要的是，MSWasm的设计使得易于在执行机制之间切换；当快速（特别是基于硬件的）执行技术可用时，MSWasm将能够几乎免费地利用这些进展。

## Work

本文基于之前的工作，实现了MSWasm的愿景，这是通过以下五个贡献实现的：

1. MSWasm的语义和内存安全（第3节）。我们的第一个贡献是将MSWasm作为Wasm语言、类型系统和操作语义的扩展进行了正式规范化。我们的语义为之前的非正式设计[Disselkoen等人，2019]提供了精确的含义。此外，这些语义使我们能够证明所有经过良好类型检查的MSWasm程序在与任意代码链接时都是健壮的内存安全的；换句话说，MSWasm程序在与任意代码链接时都是内存安全的。
2. 基于颜色的内存安全监控器（第4节）。我们开发了一种基于带颜色的内存位置和指针的新型抽象内存安全监控器，用它来证明MSWasm是内存安全的。颜色抽象了MSWasm后端可以使用的具体内存安全机制。此外，它们使得可以对个别内存对象和结构化对象的空间和时间内存安全进行推理。此外，由于我们的内存安全监控器不受编程语言的限制，因此我们可以跨编译进行内存安全推理，并在下一个贡献中建立基于编译器的内存安全执行的完整性。
3. 
